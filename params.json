{"name":"Siberite","tagline":"Siberite is a simple, lightweight, leveldb backed message queue written in Go.","body":"# Siberite\r\n[![Build Status](https://travis-ci.org/bogdanovich/siberite.svg?branch=master)](https://travis-ci.org/bogdanovich/siberite)\r\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/bogdanovich/siberite?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n[![Go Walker](http://gowalker.org/api/v1/badge)](https://gowalker.org/github.com/bogdanovich/siberite)\r\n\r\nSiberite is a simple leveldb backed message queue server<br>\r\n([twitter/kestrel](https://github.com/twitter/kestrel), [wavii/darner](https://github.com/wavii/darner) rewritten in Go).\r\n\r\nSiberite is a very simple message queue server.  Unlike in-memory servers such as [redis](http://redis.io/), Siberite is\r\ndesigned to handle queues much larger than what can be held in RAM.  And unlike enterprise queue servers such as\r\n[RabbitMQ](http://www.rabbitmq.com/), Siberite keeps all messages **out of process**,\r\nusing [goleveldb](https://github.com/syndtr/goleveldb) as a persistent storage.\r\n\r\nThe result is a durable queue server that uses a small amount of in-resident memory regardless of queue size.\r\n\r\nSiberite is based on Robey Pointer's [Kestrel](https://github.com/robey/kestrel) - simple, distributed message queue.\r\nLike Kestrel, Siberite follows the \"No talking! Shhh!\" approach to distributed queues:\r\nA single Siberite server has a set of queues identified by name.  Each queue is a strictly-ordered FIFO,\r\nand querying from a fleet of Siberite servers provides a loosely-ordered queue.\r\nSiberite also supports Kestrel's two-phase reliable fetch: if a client disconnects before confirming it handled\r\na message, the message will be handed to the next client.\r\n\r\nCompared to Kestrel and Darner, Siberite is easier to build, maintain and distribute.\r\nIt uses an order of magnitude less memory compared to Kestrel, but has less configuration far fewer features.\r\n\r\nSiberite is used at [Spyonweb.com](http://spyonweb.com).<br>\r\nWe used to use Darner before, but got 2 large production queues corrupted at some point and decided to rewrite it in Go.\r\n\r\n## Features\r\n\r\n1. Multiple consumer groups per queue using `get <queue>:<cursor>` syntax.\r\n\r\n  - When you read an item in a usual way: `get <queue>`, item gets expired and deleted.\r\n  - When you read an item using cursor syntax `get <queue>:<cursor>`, a durable\r\n    cursor gets initialized. It shifts forward with every read without deleting\r\n    any messages in the source queue. Number of cursors per queue is not limited.\r\n  - If you continue reads from the source queue directly, siberite will continue\r\n    deleting messages from the head of that queue. Any existing cursor that is\r\n    internally points to an already deleted message will catch up during next read\r\n    and will start serving messages from the current source queue head.\r\n  - Durable cursors are also support two-phase reliable reads. All failed reliable\r\n    reads for each cursor are stored in cursor's own small persistent queue.\r\n\r\n2. Fanout queues\r\n\r\n  - Siberite allows you to insert new message into multiple queues at once\r\n    by using the following syntax `set <queue>+<another_queue>+<third_queue> ...`\r\n\r\n\r\n\r\n##Benchmarks\r\n\r\n[Siberite performance benchmarks](docs/benchmarks.md)\r\n\r\n\r\n## Build\r\n\r\nMake sure your `GOPATH` is correct\r\n\r\n```\r\ngo get github.com/bogdanovich/siberite\r\ncd $GOPATH/src/github.com/bogdanovich/siberite\r\ngo get ./...\r\ncd siberite\r\ngo build siberite.go\r\nmkdir ./data\r\n./siberite -listen localhost:22133 -data ./data\r\n2015/09/22 06:29:38 listening on 127.0.0.1:22133\r\n2015/09/22 06:29:38 initializing...\r\n2015/09/22 06:29:38 data directory:  ./data\r\n```\r\n\r\nor download [darwin-x86_64 or linux-x86_64 builds](https://github.com/bogdanovich/siberite/releases)\r\n\r\n## Protocol\r\n\r\nSiberite follows the same protocol as [Kestrel](http://github.com/robey/kestrel/blob/master/docs/guide.md#memcache),\r\nwhich is the memcache TCP text protocol.\r\n\r\n[List of compatible clients](docs/clients.md)\r\n\r\n## Telnet example\r\n\r\n```\r\ntelnet localhost 22133\r\nConnected to localhost.\r\nEscape character is '^]'.\r\n\r\nset work 0 0 10\r\n1234567890\r\nSTORED\r\n\r\nset work 0 0 2\r\n12\r\nSTORED\r\n\r\nget work\r\nVALUE work 0 10\r\n1234567890\r\nEND\r\n\r\nget work/open\r\nVALUE work 0 2\r\n12\r\nEND\r\n\r\nget work/close\r\nEND\r\n\r\nstats\r\nSTAT uptime 47\r\nSTAT time 1443308758\r\nSTAT version siberite-0.4.1\r\nSTAT curr_connections 1\r\nSTAT total_connections 1\r\nSTAT cmd_get 2\r\nSTAT cmd_set 2\r\nSTAT queue_work_items 0\r\nSTAT queue_work_open_transactions 0\r\nEND\r\n\r\n# other commands:\r\n# get work/peek\r\n# get work/open\r\n# get work/close/open\r\n# get work/abort\r\n# flush work\r\n# delete work\r\n# flush_all\r\n```\r\n\r\n\r\n## Not supported\r\n\r\n  - Waiting a given time limit for a new item to arrive /t=<milliseconds> (allowed by protocol but does nothing)\r\n","google":"UA-69855897-1","note":"Don't delete this file! It's used internally to help with page regeneration."}